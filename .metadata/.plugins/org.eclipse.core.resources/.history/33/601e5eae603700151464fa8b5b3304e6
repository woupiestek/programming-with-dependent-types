

/**
 * @author Wouter
 *
 */
trait Expression { val prettyPrint: String }
case class Application(operator: Expression, operand: Expression) extends Expression {
  //Applications easily become ambiguous
  val prettyPrint = {
    val term1 = operator match {
      case _: Abstraction => "(%s)".format(operator.prettyPrint)
      case _: Expression  => operator.prettyPrint
    }
    val term2 = operand match {
      case _: Application => "(%s)".format(operand.prettyPrint)
      case _: Expression  => operand.prettyPrint
    }
    "%s %s".format(term1, term2)
  }
}
case class Universe(level: Int) extends Expression { val prettyPrint = "Type(%d)".format(level) }
trait Variable extends Expression
case class Abstraction(variable: Variable, domain: Expression, term: Expression) extends Expression {
  val prettyPrint = "(\\%s:%s.%s)".format(variable.prettyPrint, domain.prettyPrint, term.prettyPrint)
}
case class Product(typeMap: Abstraction) extends Expression {
  val prettyPrint = "Product(%s)".format(typeMap.prettyPrint)
}

/* subtypes of Variable */
case class Named(name: String) extends Variable {
  val prettyPrint = name
}
private case class Gensym(name: String, number: Int) extends Variable {
  val prettyPrint = name + number
}
case class Dummy() extends Variable {
  val prettyPrint = "_"
}

//variable generator
object Fresh {
  var count = 0;
  def apply(): Variable = {
    val freshVariable = Gensym("x", count)
    count += 1
    freshVariable
  }
}

//substitution
object Substitute {
  def apply(record: Map[Variable, Expression], expression: Expression): Expression = {
    expression match {
      case x: Variable       => record.getOrElse(x, expression)
      case u: Universe       => u
      case Product(a)        => Product(substituteAbstraction(record, a))
      case a: Abstraction    => substituteAbstraction(record, a)
      case Application(t, u) => Application(Substitute(record, t), Substitute(record, u))
    }
  }

  //need capture avoiding substitution
  //i.e. no expression in the map can have the abstracted variable in it
  //
  private def substituteAbstraction(record: Map[Variable, Expression], abstraction: Abstraction): Abstraction = {
    val alternative = Map(abstraction.variable -> Fresh())
    val record2 = for ((vari, expr) <- record if vari != abstraction.variable) yield {
      (vari, Substitute(alternative, expr))
    }
    abstraction
  }
}

