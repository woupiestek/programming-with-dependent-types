package nl.woupiestek.andrej

/**
 * @author Wouter
 */
object Infer {
  type Context = Map[Variable, Expression]

  def apply(context: Context, expression: Expression): Option[Expression] = {
    expression match {
      case x: Variable => Some(context(x)) //exception intended
      case Universe(n) => Some(Universe(n + 1))
      case Product(Abstraction(v, d, t)) => {
        for (
          k1 <- inferUniverse(context, d);
          k2 <- inferUniverse(context + (v -> d), t)
        ) yield Universe(Math.max(k1, k2))

      }
      case Abstraction(v, d, t) => {
        for (
          _ <- inferUniverse(context, d);
          te <- apply(context + (v -> d), t)
        ) yield Product(Abstraction(v, d, te))
      }
    }
  }

  private def inferUniverse(context: Context, expression: Expression): Option[Int] = {
    (Infer.apply(context, expression).map { normalize(context, _) }) match {
      case Some(Universe(k)) => Some(k)
      case _                 => None
    }
  }

  private def inferProduct(context: Context, expression: Expression) = {
    (Infer.apply(context, expression).map { normalize(context, _) }) match {
      case Some(Product(k)) => Some(k)
      case _                => None
    }
  }

  private def unify(context: Context, e1: Expression, e2: Expression): Option[Unit] = {
    if (e1 == e2) Some() else None
  }

  //TODO
  private def normalize(context: Context, expression: Expression): Expression = {
    expression match {
      case x: Variable => context get x match {
        case Some(e) => normalize(context, e)
        case None    => x
      }
      case Application(t, u) => {
        val v = normalize(context, u)
        normalize(context, t) match {
          case Abstraction(x, d, w) => normalize(context, Substitute(context + (x -> v), w))
          case s                    => Application(s, v)
        }
      }
      case u: Universe    => u
      case Product(a)     => Product(normalizeAbstraction(context, a))
      case a: Abstraction => normalizeAbstraction(context, a)

    }
  }

  private def normalizeAbstraction(context: Context, abstraction: Abstraction): Abstraction = {
    val v = abstraction.variable
    val d = normalize(context, abstraction.domain)
    Abstraction(v, d, normalize(context + (v -> d), abstraction.term))
  }

}