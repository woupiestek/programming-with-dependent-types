package nl.woupiestek.andrej

/**
 * @author Wouter
 */
object Infer {
  type Context = Map[Variable, Expression]

  def apply(context: Context, expression: Expression): Option[Expression] = {
    expression match {
      case x: Variable => Some(context(x)) //exception intended
      case Universe(n) => Some(Universe(n + 1))
      case Product(Abstraction(v, d, t)) => {
        for (
          k1 <- inferUniverse(context, d);
          k2 <- inferUniverse(context + (v -> d), t)
        ) yield Universe(Math.max(k1, k2))

      }
      case Abstraction(v, d, t) => {
        for (
          _ <- inferUniverse(context, d);
          te <- apply(context + (v -> d), t)
        ) yield Product(Abstraction(v, d, te))
      }
      case Application(t, u) => {
        for (
          a <- inferProduct(context, t);
          te <- apply(context, u) if unifiable(a.domain, te)
        ) yield {
          Substitute(Map(a.variable -> u), a.term)
        }

      }
    }
  }

  private def inferUniverse(context: Context, expression: Expression): Option[Int] = {
    (Infer.apply(context, expression).map { Evaluate(_) }) match {
      case Some(Universe(k)) => Some(k)
      case _                 => None
    }
  }

  private def inferProduct(context: Context, expression: Expression) = {
    (Infer.apply(context, expression).map { Evaluate(_) }) match {
      case Some(Product(k)) => Some(k)
      case _                => None
    }
  }

  //TODO
  def unifiable(e1: Expression, e2: Expression): Boolean = {
    e1 match {
      case Application(x, y) => e2 match {
        case Application(x2, y2) => unifiable(x, x2) && unifiable(y, y2)
        case _                   => false
      }
      case Product(x) => e2 match {
        case Product(y) => unifiable(x, y)
        case _          => false
      }
      case x: Abstraction => e2 match {
        case y: Abstraction => unifiableAbstraction(x, y)
        case _              => false
      }
      case _ => e1 == e2
    }
  }

  private def unifiableAbstraction(a1: Abstraction, a2: Abstraction): Boolean = {
    a1.domain == a2.domain && unifiable(Substitute(Map(a1.variable -> a2.variable), a1.term), a2.term)
  }

  /*  //TODO
  private def normalize(context: Context, expression: Expression): Expression = {
    expression match {
      case x: Variable => context get x match {
        case Some(e) => normalize(context, e)
        case None    => x
      }
      case Application(t, u) => {
        val v = normalize(context, u)
        normalize(context, t) match {
          case Abstraction(x, d, w) => normalize(context, Substitute(context + (x -> v), w))
          case s                    => Application(s, v)
        }
      }
      case u: Universe    => u
      case Product(a)     => Product(normalizeAbstraction(context, a))
      case a: Abstraction => normalizeAbstraction(context, a)

    }
  }

  private def normalizeAbstraction(context: Context, abstraction: Abstraction): Abstraction = {
    val v = abstraction.variable
    val d = normalize(context, abstraction.domain)
    Abstraction(v, d, normalize(context + (v -> d), abstraction.term))
  }
*/
}