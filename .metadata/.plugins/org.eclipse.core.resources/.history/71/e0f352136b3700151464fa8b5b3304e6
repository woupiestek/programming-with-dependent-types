package nl.woupiestek.andrej

/**
 * @author Wouter
 */
object Infer {
  type Context = Map[Variable, Expression]

  def apply(context: Context, expression: Expression): Option[Expression] = {
    expression match {
      case x: Variable => Some(context(x)) //exception intended
      case Universe(n) => Some(Universe(n + 1))
      case Product(Abstraction(v, d, t)) => {
        for (
          k1 <- inferUniverse(context, d);
          k2 <- inferUniverse(context + (v -> d), t)
        ) yield {
          Universe(Math.max(k1, k2))
        }
      }
      case Abstraction(v, d, t) => {
        inferUniverse(context, d).flatMap(_ =>
          for (
            te <- apply(context + (v -> d), t)
          ) yield {
            Product(Abstraction(v, d, te))
          })
      }
    }
  }

  private def inferUniverse(context: Context, expression: Expression): Option[Int] = {
    (Infer.apply(context, expression).map { normalize(context, _) }) match {
      case Some(Universe(k)) => Some(k)
      case _                 => None
    }
  }

  //TODO
  def normalize(context: Context, expression: Expression) = { expression }

}